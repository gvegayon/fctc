---
title: "FCTC implementation"
output: pdf_document
---

# Continuous exposure

Exposure is defined as

The exposure for the vertex $i\in V$ can be computed as

$$E_t = \left(A_t \times X_t\right) / (A_t \times \mathbf{1}_n)$$

Where $A_t$ is the adjacency matrix at time $t$, $X_t$ is a vector of length $n$ which holds the proportion of adoption of the innovation at time $t$, and $\mathcal{1}_n$ is a vector of ones of length $n$.

```{r Setup, warning=FALSE, message=FALSE, echo=FALSE, cache=TRUE}
library(foreign)
library(netdiffuseR)

implementation <- read.dta("~/Dropbox/usc/research/fctc/implementation/imp_04142015.dta")
edgelist       <- read.dta("~/Dropbox/usc/research/fctc/allnets.dta")
countries      <- read.dta("~/Dropbox/usc/research/fctc/attributes_v3.dta")

# Classifying
classifications <- read.table("~/Dropbox/usc/research/fctc/network_classification.csv", sep=".",
                              stringsAsFactors = FALSE, allowEscapes = TRUE)
colnames(classifications) <- c("id", "description", "static")
classifications$static <- classifications$static == "static"
classifications$description <- trimws(classifications$description, "both")

# Classifying the edgelist
edgelist$net <- factor(
  classifications$description[edgelist$relation],
  levels=classifications$description)

# Adoption (or partial adoption)
imp <- grepl("^var",colnames(implementation))
implementation$count <- rowSums(implementation[,imp], na.rm = TRUE)

# Exposure
toa_implementation <- subset(implementation, select=c(year, countrynameun, meanall))
toa_implementation <- reshape(
  toa_implementation,
  direction = "wide", timevar = "year",
  idvar="countrynameun")

toa_implementation <- merge(
  unique(subset(countries, select=c(id, countrynameun))),
  toa_implementation,
  by = "countrynameun",
  all.x=TRUE, all.y=FALSE
)

toa_implementation[is.na(toa_implementation)] <- 0

# Sorting
toa_implementation <- toa_implementation[order(
  as.character(toa_implementation$id)
),]


# Creating diffnetobjects
i        <- 1
relations <- c(1, 2, 3, 12, 13, 14)
diffnets <- vector("list", length(relations))
for (r in relations) {
  E <- subset(edgelist, relation == r)
  
  # Checkiong if there is data or not
  if (!nrow(E)) {
    next
  }
  
  t1 <- if (r %in%  c(1,12:14)) NULL else E$year
  tran <- range(E$year)
  
  diffnets[[i]] <- edgelist_to_diffnet(
    edgelist = E[,c("id","nom")],
    t0       = E$year,
    t1       = t1,
    # Be sure the data are the same as the spanned time in the network!
    dat      = subset(countries, year %in% tran[1]:tran[2]),
    idvar = "id", toavar = "toa_year_fctc", timevar="year",
    warn.coercion = FALSE,
    fill.missing = "both" # fill missing in either network or adoption
  )
  
  i <- i+1
}

# CONTINUOUS EXPOSURE ----------------------------------------------------------

# Coercing into appropiate dimension
nper <- diffnets[[1]]$meta$nper
n    <- diffnets[[1]]$meta$n
cumadopt <- matrix(0,ncol=nper, nrow=n)
cumadopt[,nper] <- toa_implementation$meanall.2014
cumadopt[,(nper-2):(nper-1)] <- toa_implementation$meanall.2012
cumadopt[,(nper-4):(nper-3)] <- toa_implementation$meanall.2010

# Computing for each network
dat <- vector("list", length(diffnets))
i <- 1
for (dn in diffnets) {
  
  if (length(dn)) {
    dn[["cont_exposure"]] <- exposure(dn, cumadopt = cumadopt)
    dat[[i]] <- diffnet.attrs(dn[,,6:10], as.df = TRUE)
  }
  i <- i + 1
}
```

```{r, echo=FALSE, fig.width=10, fig.height=9, cache=TRUE}
oldpar <- par(no.readonly = TRUE)
par(mfrow=c(2,3), mai=c(.25,.25,.55,.25), omi=rep(1,4))
for (i in 1:length(dat)) {
  # Plotting
  par(cex=.9)
  d <- dat[[i]]
  with(d, plot(cont_exposure, meanall, xlim=c(0,1), ylim=c(0,1),
               main=sprintf(
                 "%s",
                 classifications$description[relations[i]]),
               pch = 15,
               col = rgb(.3,.3,.7,.5)
               ))
  
  # Adding correlation coefficient
  p <- with(d, cor(cont_exposure, meanall,use = "pairwise.complete.obs"))
  b <- coef(with(d, lm(meanall~cont_exposure)))
  par(cex=1.2)
  text(.95,.95,sprintf("Cor: %.3f", p), pos=2)
  abline(b[1], b[2], lwd=2)
}
title("Continuous Adoption vs Exposure",outer=TRUE,
      xlab="Continuous exposure", ylab="'meanall'")
par(oldpar)
```

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.width=10, fig.height=7, cache=TRUE}
# Computing vertex size
size <- rowMeans(toa_implementation[,c(-1,-2)], na.rm = TRUE)/2
cols <- data.frame(id=toa_implementation$id, size=size,
                   stringsAsFactors = FALSE)
cols <- cols[order(-cols$size),]
cols$col <- heat.colors(length(size), alpha = .7)
cols <- cols[order(as.character(cols$id)),]$col
cols <- col2rgb(cols)/255
cols <- rgb(cols[1,], cols[2,], cols[3,], size)

oldpar <- par(no.readonly = TRUE)
par(mfrow=c(2,3), mai=c(.25,.1,.55,.1), omi=rep(1,4))
for (i in 1:length(diffnets)) {
  # Plotting
  par(cex=.9)
  d <- diffnets[[i]]
  plot_threshold(d, main=sprintf(
                 "%s",
                 classifications$description[relations[i]]),
                 vertex.cex = size,
                 vertex.col = cols)
}
title("Continuous Adoption vs Exposure",outer=TRUE,
      xlab="Year", ylab="Threshold", 
      sub = "Size and color intensity given by 'meanall'")
par(oldpar)
```

```{r}
library(netdiffuseR)
plot_threshold(
  diffnets[[2]],
  main="",
  vertex.cex = size, vertex.col=cols
)
```

